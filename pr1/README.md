#Бабаянц Т. A. ИКБО-63-23

#Практическое занятие №5. Вопросы виртуализации

#П.Н. Советов, РТУ МИРЭА


#Задача 1

Исследование виртуальной стековой машины CPython.

Изучите возможности просмотра байткода ВМ CPython.

import dis

def foo(x):
    while x:
        x -= 1
    return x + 1

print(dis.dis(foo))
Опишите по шагам, что делает каждая из следующих команд (приведите эквивалентное выражение на Python):

11 0 LOAD_FAST 0 (x) 2 LOAD_CONST 1 (10) 4 BINARY_MULTIPLY 6 LOAD_CONST 2 (42) 8 BINARY_ADD 10 RETURN_VALUE

#Решение:

Байткод:
11  0 LOAD_FAST                0 (x)           # Загружает значение переменной x (0 - это индекс переменной)
    2 LOAD_CONST               1 (10)          # Загружает константу 10
    4 BINARY_MULTIPLY                          # Умножает значение x на 10
    6 LOAD_CONST               2 (42)          # Загружает константу 42
    8 BINARY_ADD                              # Сложение результата предыдущего умножения с 42
   10 RETURN_VALUE                            # Возвращает итоговое значение
Описание команд:
LOAD_FAST 0 (x):

Описание: Эта команда загружает значение локальной переменной x.
Эквивалентное выражение: x
Пример: Если x = 5, то после выполнения этой команды стек будет содержать 5.
LOAD_CONST 1 (10):

Описание: Эта команда загружает константу 10 в стек.
Эквивалентное выражение: 10
Пример: Теперь в стеке будет два значения: 5 (значение x) и 10.
BINARY_MULTIPLY:

Описание: Эта команда умножает два верхних значения в стеке.
Эквивалентное выражение: x * 10
Пример: Если в стеке 5 и 10, результатом будет 50. Теперь стек будет содержать только 50.
LOAD_CONST 2 (42):

Описание: Эта команда загружает константу 42 в стек.
Эквивалентное выражение: 42
Пример: Теперь в стеке будет 50 и 42.
BINARY_ADD:

Описание: Эта команда складывает два верхних значения в стеке.
Эквивалентное выражение: 50 + 42
Пример: Результат сложения 50 и 42 будет 92. Теперь стек содержит только 92.
RETURN_VALUE:

Описание: Эта команда возвращает верхнее значение из стека как результат выполнения функции.
Эквивалентное выражение: return 92
Пример: Завершает выполнение функции и возвращает значение 92.
Полное эквивалентное выражение на Python
Таким образом, весь процесс можно свести к следующему выражению на Python:

def foo(x):
    return (x * 10) + 42
Если, например, x = 5, то вызов foo(5) вернет 92, что соответствует результату работы байткода.

#Задача 2

Что делает следующий байткод (опишите шаги его работы)? Это известная функция, назовите ее.

  5           0 LOAD_CONST               1 (1)
              2 STORE_FAST               1 (r)

  6     >>    4 LOAD_FAST                0 (n)
              6 LOAD_CONST               1 (1)
              8 COMPARE_OP               4 (>)
             10 POP_JUMP_IF_FALSE       30

  7          12 LOAD_FAST                1 (r)
             14 LOAD_FAST                0 (n)
             16 INPLACE_MULTIPLY
             18 STORE_FAST               1 (r)

  8          20 LOAD_FAST                0 (n)
             22 LOAD_CONST               1 (1)
             24 INPLACE_SUBTRACT
             26 STORE_FAST               0 (n)
             28 JUMP_ABSOLUTE            4

  9     >>   30 LOAD_FAST                1 (r)
             32 RETURN_VALUE
#Решение:

Этот байткод представляет собой реализацию известной функции — факториала.

Описание байткода и его эквивалента на Python:
Функция рассчитывает факториал числа n в императивном стиле (с использованием цикла).

Байткод с комментариями:
  5           0 LOAD_CONST               1 (1)      # Загружает константу 1
              2 STORE_FAST               1 (r)      # Сохраняет значение 1 в переменную r

  6     >>    4 LOAD_FAST                0 (n)      # Загружает значение n
              6 LOAD_CONST               1 (1)      # Загружает константу 1
              8 COMPARE_OP               4 (>)      # Проверяет, больше ли n 1
             10 POP_JUMP_IF_FALSE       30          # Если n <= 1, переходит к адресу 30 (завершение)

  7          12 LOAD_FAST                1 (r)      # Загружает значение r
             14 LOAD_FAST                0 (n)      # Загружает значение n
             16 INPLACE_MULTIPLY                      # Умножает r на n
             18 STORE_FAST               1 (r)      # Сохраняет результат обратно в r

  8          20 LOAD_FAST                0 (n)      # Загружает значение n
             22 LOAD_CONST               1 (1)      # Загружает константу 1
             24 INPLACE_SUBTRACT                      # Вычитает 1 из n
             26 STORE_FAST               0 (n)      # Сохраняет результат обратно в n
             28 JUMP_ABSOLUTE            4          # Переходит к началу цикла (проверка условия n > 1)

  9     >>   30 LOAD_FAST                1 (r)      # Загружает значение r (итоговый результат)
             32 RETURN_VALUE                          # Возвращает r как результат функции
Пошаговый разбор:
Инициализация r:

Устанавливает переменную r в 1. Переменная r будет накапливать произведение чисел от n до 1.
Проверка условия n > 1:

Загружает n и проверяет, больше ли оно 1. Если нет, программа завершает цикл и возвращает результат в r.
Умножение и уменьшение n:

Если n > 1, значение r умножается на n, а затем n уменьшается на 1.
Этот шаг повторяется до тех пор, пока n не станет равным 1.
Возврат результата:

Когда n становится меньше или равным 1, цикл завершается, и программа возвращает r, который содержит факториал начального значения n.
Эквивалентный код на Python:
Этот байткод эквивалентен следующему коду Python, который вычисляет факториал числа n с помощью цикла:

def factorial(n):
    r = 1
    while n > 1:
        r *= n
        n -= 1
    return r
Заключение
Этот байткод представляет собой реализацию функции факториала с использованием цикла while.

#Задача 3

Приведите результаты из задач 1 и 2 для виртуальной машины JVM (Java) или .Net (C#).

#Решение:

Задача 1 (выражение x * 10 + 42):
import java.util.Scanner;

public class Task1 {
    public static int calculate(int x) {
        return x * 10 + 42;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Введите число x: ");
        int x = scanner.nextInt();

        int result = calculate(x);
        System.out.println("Результат: " + result);
    }
}
Байткод JVM для функции calculate
Байткод JVM для этой функции можно сгенерировать с помощью команды javap -c Task1. Результат будет примерно следующим:

public static int calculate(int);
  Code:
     0: iload_0           // Загружаем x в стек
     1: bipush 10         // Загружаем константу 10 в стек
     3: imul              // Умножаем x на 10
     4: bipush 42         // Загружаем константу 42 в стек
     6: iadd              // Складываем результат умножения с 42
     7: ireturn           // Возвращаем итоговое значение
Задача 2 (факториал):
import java.util.Scanner;

public class Task2 {
    public static int factorial(int n) {
        int r = 1;
        while (n > 1) {
            r *= n;
            n -= 1;
        }
        return r;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Введите число для вычисления факториала: ");
        int n = scanner.nextInt();

        int result = factorial(n);
        System.out.println("Факториал: " + result);
    }
}
Байткод JVM для функции factorial
Для просмотра байткода функции factorial можно снова использовать команду javap -c Task2. Результат будет примерно следующим:

public static int factorial(int);
  Code:
     0: iconst_1              // Инициализируем r = 1
     1: istore_1              // Сохраняем значение 1 в переменную r
     2: iload_0               // Загружаем значение n в стек
     3: iconst_1              // Загружаем константу 1 в стек
     4: if_icmple 22          // Проверяем, n > 1; если нет, переходим к завершению
     7: iload_1               // Загружаем r в стек
     8: iload_0               // Загружаем n в стек
     9: imul                  // Умножаем r на n
    10: istore_1              // Сохраняем результат в r
    11: iload_0               // Загружаем n в стек
    12: iconst_1              // Загружаем 1 в стек
    13: isub                  // Вычитаем 1 из n
    14: istore_0              // Сохраняем результат в n
    15: goto 2                // Переход к началу цикла
    22: iload_1               // Загружаем r в стек (итоговый результат)
    23: ireturn               // Возвращаем r

#Результат:

image

image

#Задача 4

Работа с qemu. Скачать и установить ISO-образ Alpine Linux для виртуальных машин с официального сайта. Создать с помощью qemu образ жесткого диска (опция -f qcow2). Объем диска 500 Мб. Запустить Alpine Linux с CD-ROM. Установить систему на sda. Изменить motd. Загрузиться уже с sda. Прислать полный список команд для установки и загрузки, а также скриншот с motd, где фигурируют ваши имя и фамилия.

#Решение:

qemu-img create -f qcow2 alpine_disk.qcow2 500M
qemu-system-x86_64 -m 512 -nic user -boot d -cdrom alpine-virt-3.20.3-x86_64.iso -hda alpine_disk.qcow2 -display gtk
setup-alpine
qemu-system-x86_64 -m 512 -nic user -hda alpine_disk.qcow2
apk add nano
nano /etc/motd
reboot
Результат:
image

#Задача 5

(после разбора на семинаре и написания у доски базовой части эмулятора древней игровой приставки CHIP-8)

Реализовать вывод на экран.
Добиться запуска Тетриса.
Реализовать ввод с клавиатуры.
Добиться успешной работы всех приложений.
Архив эмулятора CHIP-8

#Решение:

Результат:
Полезные ссылки
Compiler Explorer: https://godbolt.org/

Байткод CPython: https://docs.python.org/3/library/dis.html

QEMU для Windows: https://www.qemu.org/download/#windows http://sovietov.com/tmp/mqemu.zip

Документация по QEMU: https://www.qemu.org/docs/master/system/index.html

Старая документация по QEMU (рус.): https://www.opennet.ru/docs/RUS/qemu_doc/

Образы Alpine Linux: https://alpinelinux.org/downloads/

Документация по игровому компьютеру CHIP-8: http://devernay.free.fr/hacks/chip8/C8TECH10.HTM

Учебник по созданию миниатюрной ОС: https://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf

Nasm: https://nasm.us/

Прерывания BIOS: http://www.ctyme.com/intr/int.htm

Игры в загрузочном секторе: https://github.com/nanochess/Invaders
